use tonic::Status;
use wasm_bindgen_futures::spawn_local;
use yew_agent::{HandlerId, Public, WorkerLink};
use serde::{Serialize, Deserialize};
use tonic_web_wasm_client::Client;

#[allow(non_snake_case)]
pub mod proto {
  tonic::include_proto!("book_merger");
}

use proto::orderbook_aggregator_client::OrderbookAggregatorClient;
use self::proto::Summary;

pub enum MsgWorker {
  EsReady(Summary),
  EsError(Status),
}

#[derive(Serialize, Deserialize)]
pub enum WorkerRequest {
   GetGRPC
}

pub struct Worker {
  link: WorkerLink<Self>,
  book_updates: Vec<Summary>,
}

#[derive(Serialize, Deserialize)]
pub struct WorkerInput {
  pub req: WorkerRequest,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct WorkerOutput {
  pub book: Vec<Summary>,
}

impl yew_agent::Worker for Worker {
    type Input = WorkerInput;
    type Message = MsgWorker;
    type Output = WorkerOutput;
    type Reach = Public<Self>;
    fn create(link: WorkerLink<Self>) -> Self {
      log::info!("worker grpc starting");
      let link_ = link.clone();
      spawn_local(async move {
        log::info!("worker grpc starting");
        let base_url = "http://localhost:50051".to_string(); // URL of the gRPC-web server
        let c = Client::new(base_url);
        let mut query_client = OrderbookAggregatorClient::new(c); // `QueryClient` is the client generated by tonic
        let empty_msg = proto::Empty {};
        match query_client.book_summary(empty_msg).await {
          Ok(response) => {
            let mut stream_grpc = response.into_inner();
            while let Some(res) = stream_grpc.message().await.unwrap() {
              link_.send_message(Self::Message::EsReady(res.clone()));
            }
          },
          Err(e) => {
            link_.send_message(Self::Message::EsError(e));
          }
        }
      });
        Self {
          link,
          book_updates: Vec::new(),
        }
    }

    fn update(&mut self, msg: Self::Message) {
        match msg {
          Self::Message::EsReady(response) => {
            self.book_updates.push(response);
            //log::info!("grpc : {:?}", response);
          },
          Self::Message::EsError(e) => {
            log::info!("grpc error: {:?}", e);
            //self.book_updates.push(e.to_string());
          }
        }
    }

    fn handle_input(&mut self, msg: Self::Input, id: HandlerId) {
        match msg.req {
          WorkerRequest::GetGRPC => {
            let output = Self::Output { book: self.book_updates.clone() };
            self.link.respond(id, output);
            self.book_updates.clear();
          },
      }
    }

    fn name_of_resource() -> &'static str {
        "worker.js"
    }

    fn resource_path_is_relative() -> bool {
        true
    }
}
